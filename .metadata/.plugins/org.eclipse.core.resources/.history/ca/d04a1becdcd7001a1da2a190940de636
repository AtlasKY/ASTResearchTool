
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.control.CompilePhase
import org.codehaus.groovy.control.CompilerConfiguration

class ConsistencyAnalysis {
	
	List handlers
	List devices
	
	List results
	
	public ConsistencyAnalysis(List hdls, List devs) {
		
		handlers = new ArrayList()
		handlers = hdls
		
		devices = new ArrayList()
		devices = devs
		
		results = new ArrayList<AnalysisResult>()
		
	}
	
	void analyse() {
		
		for(int i = 0; i < handlers.size(); i++) {
			
			for(int j = i; j < handlers.size(); j++) {
				
				results.add(analysisHelper(handlers.get(i), handlers.get(j)))
				
			}	
		}
	}
	
	AnalysisResult analysisHelper(Handler h1, Handler h2) {
		
		AnalysisResult ar = new AnalysisResult(h1, h2)
		
		stateAnalysis(ar, h1, h2)
		
		userImpactAnalysis(ar, h1, h2)
		
		devModAnalysis(ar, h1, h2)
	}
	
	int stateAnalysis(AnalysisResult ar, Handler h1, Handler h2) {
		
	}
	
	int userImpactAnalysis(AnalysisResult ar, Handler h1, Handler h2) {
		
	}
	
	int devModAnalysis(AnalysisResult ar, Handler h1, Handler h2) {
		
	}
	
	//An object to store the result of the analysis
	//The handlers involved hdl1 and hdl2
	//The issues come across
	class AnalysisResult{
		
		Handler hdl1
		Handler hdl2
		
		int stateMod
		int usrImp
		int deviceMod
		
		String result
		
		public AnalysisResult(Handler h1, Handler h2) {
			
			hdl1 = h1
			hdl2 = h2
			result = ""
			
		}
		
		void stateRes(int h1, int h2) {
			
			//0: no state usage
			//1: safe read state only
			//2: safe write state only
			//3: safe read and write
			//4: unsafe read state only
			//5: unsafe write state only
			//6: unsafe read and write
			if(h1 == 0 && h2 == 0) {
				result += "No state usage in the handlers\n"
			}
			else if(h1 < 4 && h2 < 4) {
				result += "State Safe!\n"
				switch(h1) {
					case 0:
						result += "Handler 1 does not use state\n"
						break;
					case 1:
						result += "Handler 1 " + hdl1.name + "only reads state variables "
						hdl1.readStates.each { s-> result += s + "; "}
						break;
					case 2:
						result += "Handler 1 " + hdl1.name + "only writes state variables "
						result += "writes state variables "
						hdl1.writeStates.each { s-> result += s + "; "}
						break;
					case 3:
						result += "Handler 1 " + hdl1.name + "reads state variables "
						hdl1.readStates.each { s-> result += s + "; "}
						result += "writes state variables "
						hdl1.writeStates.each { s->	result += rs + "; "}
						break;
				}
				switch(h2) {
					case 0:
						result += "Handler 2 does not use state\n"
						break;
					case 1:
						result += "Handler 2 " + hdl2.name + "only reads state variables "
						hdl2.readStates.each { s-> result += s + "; "}
						break;
					case 2:
						result += "Handler 2 " + hdl2.name + "only writes state variables "
						result += "writes state variables "
						hdl2.writeStates.each { s-> result += s + "; "}
						break;
					case 3:
						result += "Handler 2 " + hdl2.name + "reads state variables "
						hdl2.readStates.each { s-> result += s + "; "}
						result += "writes state variables "
						hdl2.writeStates.each { s-> result += s + "; "}
						break;
				}
			}
			
			
		}
		
		void usrImpRes(int res) {
			usrImp = res
		}
		
		void devModRes(int res) {
			deviceMod = res
		}
		
	}
	
}
